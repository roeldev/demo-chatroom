// Code generated by protoc-gen-connect-go. DO NOT EDIT.
//
// Source: api/v1/apiv1.proto

package apiv1connect

import (
	connect "connectrpc.com/connect"
	context "context"
	errors "errors"
	v1 "github.com/roeldev/demo-chatroom/api/v1"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
	http "net/http"
	strings "strings"
)

// This is a compile-time assertion to ensure that this generated file and the connect package are
// compatible. If you get a compiler error that this constant is not defined, this code was
// generated with a version of connect newer than the one compiled into your binary. You can fix the
// problem by either regenerating this code with an older version of connect or updating the connect
// version compiled into your binary.
const _ = connect.IsAtLeastVersion1_13_0

const (
	// AuthServiceName is the fully-qualified name of the AuthService service.
	AuthServiceName = "api.v1.AuthService"
	// UserServiceName is the fully-qualified name of the UserService service.
	UserServiceName = "api.v1.UserService"
	// EventsServiceName is the fully-qualified name of the EventsService service.
	EventsServiceName = "api.v1.EventsService"
)

// These constants are the fully-qualified names of the RPCs defined in this package. They're
// exposed at runtime as Spec.Procedure and as the final two segments of the HTTP route.
//
// Note that these are different from the fully-qualified method names used by
// google.golang.org/protobuf/reflect/protoreflect. To convert from these constants to
// reflection-formatted method names, remove the leading slash and convert the remaining slash to a
// period.
const (
	// AuthServiceJoinProcedure is the fully-qualified name of the AuthService's Join RPC.
	AuthServiceJoinProcedure = "/api.v1.AuthService/Join"
	// AuthServiceRenewProcedure is the fully-qualified name of the AuthService's Renew RPC.
	AuthServiceRenewProcedure = "/api.v1.AuthService/Renew"
	// AuthServiceLeaveProcedure is the fully-qualified name of the AuthService's Leave RPC.
	AuthServiceLeaveProcedure = "/api.v1.AuthService/Leave"
	// UserServiceActiveUsersProcedure is the fully-qualified name of the UserService's ActiveUsers RPC.
	UserServiceActiveUsersProcedure = "/api.v1.UserService/ActiveUsers"
	// UserServiceUpdateDetailsProcedure is the fully-qualified name of the UserService's UpdateDetails
	// RPC.
	UserServiceUpdateDetailsProcedure = "/api.v1.UserService/UpdateDetails"
	// UserServiceUpdateStatusProcedure is the fully-qualified name of the UserService's UpdateStatus
	// RPC.
	UserServiceUpdateStatusProcedure = "/api.v1.UserService/UpdateStatus"
	// UserServiceIndicateTypingProcedure is the fully-qualified name of the UserService's
	// IndicateTyping RPC.
	UserServiceIndicateTypingProcedure = "/api.v1.UserService/IndicateTyping"
	// UserServiceSendChatProcedure is the fully-qualified name of the UserService's SendChat RPC.
	UserServiceSendChatProcedure = "/api.v1.UserService/SendChat"
	// UserServiceEditChatProcedure is the fully-qualified name of the UserService's EditChat RPC.
	UserServiceEditChatProcedure = "/api.v1.UserService/EditChat"
	// UserServiceEmojiReplyProcedure is the fully-qualified name of the UserService's EmojiReply RPC.
	UserServiceEmojiReplyProcedure = "/api.v1.UserService/EmojiReply"
	// EventsServicePreviousEventsProcedure is the fully-qualified name of the EventsService's
	// PreviousEvents RPC.
	EventsServicePreviousEventsProcedure = "/api.v1.EventsService/PreviousEvents"
	// EventsServiceEventStreamProcedure is the fully-qualified name of the EventsService's EventStream
	// RPC.
	EventsServiceEventStreamProcedure = "/api.v1.EventsService/EventStream"
)

// AuthServiceClient is a client for the api.v1.AuthService service.
type AuthServiceClient interface {
	Join(context.Context, *connect.Request[v1.JoinRequest]) (*connect.Response[v1.JoinResponse], error)
	Renew(context.Context, *connect.Request[emptypb.Empty]) (*connect.Response[v1.RenewResponse], error)
	Leave(context.Context, *connect.Request[emptypb.Empty]) (*connect.Response[emptypb.Empty], error)
}

// NewAuthServiceClient constructs a client for the api.v1.AuthService service. By default, it uses
// the Connect protocol with the binary Protobuf Codec, asks for gzipped responses, and sends
// uncompressed requests. To use the gRPC or gRPC-Web protocols, supply the connect.WithGRPC() or
// connect.WithGRPCWeb() options.
//
// The URL supplied here should be the base URL for the Connect or gRPC server (for example,
// http://api.acme.com or https://acme.com/grpc).
func NewAuthServiceClient(httpClient connect.HTTPClient, baseURL string, opts ...connect.ClientOption) AuthServiceClient {
	baseURL = strings.TrimRight(baseURL, "/")
	authServiceMethods := v1.File_api_v1_apiv1_proto.Services().ByName("AuthService").Methods()
	return &authServiceClient{
		join: connect.NewClient[v1.JoinRequest, v1.JoinResponse](
			httpClient,
			baseURL+AuthServiceJoinProcedure,
			connect.WithSchema(authServiceMethods.ByName("Join")),
			connect.WithClientOptions(opts...),
		),
		renew: connect.NewClient[emptypb.Empty, v1.RenewResponse](
			httpClient,
			baseURL+AuthServiceRenewProcedure,
			connect.WithSchema(authServiceMethods.ByName("Renew")),
			connect.WithClientOptions(opts...),
		),
		leave: connect.NewClient[emptypb.Empty, emptypb.Empty](
			httpClient,
			baseURL+AuthServiceLeaveProcedure,
			connect.WithSchema(authServiceMethods.ByName("Leave")),
			connect.WithClientOptions(opts...),
		),
	}
}

// authServiceClient implements AuthServiceClient.
type authServiceClient struct {
	join  *connect.Client[v1.JoinRequest, v1.JoinResponse]
	renew *connect.Client[emptypb.Empty, v1.RenewResponse]
	leave *connect.Client[emptypb.Empty, emptypb.Empty]
}

// Join calls api.v1.AuthService.Join.
func (c *authServiceClient) Join(ctx context.Context, req *connect.Request[v1.JoinRequest]) (*connect.Response[v1.JoinResponse], error) {
	return c.join.CallUnary(ctx, req)
}

// Renew calls api.v1.AuthService.Renew.
func (c *authServiceClient) Renew(ctx context.Context, req *connect.Request[emptypb.Empty]) (*connect.Response[v1.RenewResponse], error) {
	return c.renew.CallUnary(ctx, req)
}

// Leave calls api.v1.AuthService.Leave.
func (c *authServiceClient) Leave(ctx context.Context, req *connect.Request[emptypb.Empty]) (*connect.Response[emptypb.Empty], error) {
	return c.leave.CallUnary(ctx, req)
}

// AuthServiceHandler is an implementation of the api.v1.AuthService service.
type AuthServiceHandler interface {
	Join(context.Context, *connect.Request[v1.JoinRequest]) (*connect.Response[v1.JoinResponse], error)
	Renew(context.Context, *connect.Request[emptypb.Empty]) (*connect.Response[v1.RenewResponse], error)
	Leave(context.Context, *connect.Request[emptypb.Empty]) (*connect.Response[emptypb.Empty], error)
}

// NewAuthServiceHandler builds an HTTP handler from the service implementation. It returns the path
// on which to mount the handler and the handler itself.
//
// By default, handlers support the Connect, gRPC, and gRPC-Web protocols with the binary Protobuf
// and JSON codecs. They also support gzip compression.
func NewAuthServiceHandler(svc AuthServiceHandler, opts ...connect.HandlerOption) (string, http.Handler) {
	authServiceMethods := v1.File_api_v1_apiv1_proto.Services().ByName("AuthService").Methods()
	authServiceJoinHandler := connect.NewUnaryHandler(
		AuthServiceJoinProcedure,
		svc.Join,
		connect.WithSchema(authServiceMethods.ByName("Join")),
		connect.WithHandlerOptions(opts...),
	)
	authServiceRenewHandler := connect.NewUnaryHandler(
		AuthServiceRenewProcedure,
		svc.Renew,
		connect.WithSchema(authServiceMethods.ByName("Renew")),
		connect.WithHandlerOptions(opts...),
	)
	authServiceLeaveHandler := connect.NewUnaryHandler(
		AuthServiceLeaveProcedure,
		svc.Leave,
		connect.WithSchema(authServiceMethods.ByName("Leave")),
		connect.WithHandlerOptions(opts...),
	)
	return "/api.v1.AuthService/", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		switch r.URL.Path {
		case AuthServiceJoinProcedure:
			authServiceJoinHandler.ServeHTTP(w, r)
		case AuthServiceRenewProcedure:
			authServiceRenewHandler.ServeHTTP(w, r)
		case AuthServiceLeaveProcedure:
			authServiceLeaveHandler.ServeHTTP(w, r)
		default:
			http.NotFound(w, r)
		}
	})
}

// UnimplementedAuthServiceHandler returns CodeUnimplemented from all methods.
type UnimplementedAuthServiceHandler struct{}

func (UnimplementedAuthServiceHandler) Join(context.Context, *connect.Request[v1.JoinRequest]) (*connect.Response[v1.JoinResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("api.v1.AuthService.Join is not implemented"))
}

func (UnimplementedAuthServiceHandler) Renew(context.Context, *connect.Request[emptypb.Empty]) (*connect.Response[v1.RenewResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("api.v1.AuthService.Renew is not implemented"))
}

func (UnimplementedAuthServiceHandler) Leave(context.Context, *connect.Request[emptypb.Empty]) (*connect.Response[emptypb.Empty], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("api.v1.AuthService.Leave is not implemented"))
}

// UserServiceClient is a client for the api.v1.UserService service.
type UserServiceClient interface {
	ActiveUsers(context.Context, *connect.Request[emptypb.Empty]) (*connect.Response[v1.ActiveUsersResponse], error)
	UpdateDetails(context.Context, *connect.Request[v1.UpdateDetailsRequest]) (*connect.Response[emptypb.Empty], error)
	UpdateStatus(context.Context, *connect.Request[v1.UpdateStatusRequest]) (*connect.Response[emptypb.Empty], error)
	IndicateTyping(context.Context, *connect.Request[v1.IndicateTypingRequest]) (*connect.Response[emptypb.Empty], error)
	SendChat(context.Context, *connect.Request[v1.SendChatRequest]) (*connect.Response[emptypb.Empty], error)
	EditChat(context.Context, *connect.Request[v1.ChatEditEvent]) (*connect.Response[emptypb.Empty], error)
	EmojiReply(context.Context, *connect.Request[v1.EmojiReplyRequest]) (*connect.Response[emptypb.Empty], error)
}

// NewUserServiceClient constructs a client for the api.v1.UserService service. By default, it uses
// the Connect protocol with the binary Protobuf Codec, asks for gzipped responses, and sends
// uncompressed requests. To use the gRPC or gRPC-Web protocols, supply the connect.WithGRPC() or
// connect.WithGRPCWeb() options.
//
// The URL supplied here should be the base URL for the Connect or gRPC server (for example,
// http://api.acme.com or https://acme.com/grpc).
func NewUserServiceClient(httpClient connect.HTTPClient, baseURL string, opts ...connect.ClientOption) UserServiceClient {
	baseURL = strings.TrimRight(baseURL, "/")
	userServiceMethods := v1.File_api_v1_apiv1_proto.Services().ByName("UserService").Methods()
	return &userServiceClient{
		activeUsers: connect.NewClient[emptypb.Empty, v1.ActiveUsersResponse](
			httpClient,
			baseURL+UserServiceActiveUsersProcedure,
			connect.WithSchema(userServiceMethods.ByName("ActiveUsers")),
			connect.WithClientOptions(opts...),
		),
		updateDetails: connect.NewClient[v1.UpdateDetailsRequest, emptypb.Empty](
			httpClient,
			baseURL+UserServiceUpdateDetailsProcedure,
			connect.WithSchema(userServiceMethods.ByName("UpdateDetails")),
			connect.WithClientOptions(opts...),
		),
		updateStatus: connect.NewClient[v1.UpdateStatusRequest, emptypb.Empty](
			httpClient,
			baseURL+UserServiceUpdateStatusProcedure,
			connect.WithSchema(userServiceMethods.ByName("UpdateStatus")),
			connect.WithClientOptions(opts...),
		),
		indicateTyping: connect.NewClient[v1.IndicateTypingRequest, emptypb.Empty](
			httpClient,
			baseURL+UserServiceIndicateTypingProcedure,
			connect.WithSchema(userServiceMethods.ByName("IndicateTyping")),
			connect.WithClientOptions(opts...),
		),
		sendChat: connect.NewClient[v1.SendChatRequest, emptypb.Empty](
			httpClient,
			baseURL+UserServiceSendChatProcedure,
			connect.WithSchema(userServiceMethods.ByName("SendChat")),
			connect.WithClientOptions(opts...),
		),
		editChat: connect.NewClient[v1.ChatEditEvent, emptypb.Empty](
			httpClient,
			baseURL+UserServiceEditChatProcedure,
			connect.WithSchema(userServiceMethods.ByName("EditChat")),
			connect.WithClientOptions(opts...),
		),
		emojiReply: connect.NewClient[v1.EmojiReplyRequest, emptypb.Empty](
			httpClient,
			baseURL+UserServiceEmojiReplyProcedure,
			connect.WithSchema(userServiceMethods.ByName("EmojiReply")),
			connect.WithClientOptions(opts...),
		),
	}
}

// userServiceClient implements UserServiceClient.
type userServiceClient struct {
	activeUsers    *connect.Client[emptypb.Empty, v1.ActiveUsersResponse]
	updateDetails  *connect.Client[v1.UpdateDetailsRequest, emptypb.Empty]
	updateStatus   *connect.Client[v1.UpdateStatusRequest, emptypb.Empty]
	indicateTyping *connect.Client[v1.IndicateTypingRequest, emptypb.Empty]
	sendChat       *connect.Client[v1.SendChatRequest, emptypb.Empty]
	editChat       *connect.Client[v1.ChatEditEvent, emptypb.Empty]
	emojiReply     *connect.Client[v1.EmojiReplyRequest, emptypb.Empty]
}

// ActiveUsers calls api.v1.UserService.ActiveUsers.
func (c *userServiceClient) ActiveUsers(ctx context.Context, req *connect.Request[emptypb.Empty]) (*connect.Response[v1.ActiveUsersResponse], error) {
	return c.activeUsers.CallUnary(ctx, req)
}

// UpdateDetails calls api.v1.UserService.UpdateDetails.
func (c *userServiceClient) UpdateDetails(ctx context.Context, req *connect.Request[v1.UpdateDetailsRequest]) (*connect.Response[emptypb.Empty], error) {
	return c.updateDetails.CallUnary(ctx, req)
}

// UpdateStatus calls api.v1.UserService.UpdateStatus.
func (c *userServiceClient) UpdateStatus(ctx context.Context, req *connect.Request[v1.UpdateStatusRequest]) (*connect.Response[emptypb.Empty], error) {
	return c.updateStatus.CallUnary(ctx, req)
}

// IndicateTyping calls api.v1.UserService.IndicateTyping.
func (c *userServiceClient) IndicateTyping(ctx context.Context, req *connect.Request[v1.IndicateTypingRequest]) (*connect.Response[emptypb.Empty], error) {
	return c.indicateTyping.CallUnary(ctx, req)
}

// SendChat calls api.v1.UserService.SendChat.
func (c *userServiceClient) SendChat(ctx context.Context, req *connect.Request[v1.SendChatRequest]) (*connect.Response[emptypb.Empty], error) {
	return c.sendChat.CallUnary(ctx, req)
}

// EditChat calls api.v1.UserService.EditChat.
func (c *userServiceClient) EditChat(ctx context.Context, req *connect.Request[v1.ChatEditEvent]) (*connect.Response[emptypb.Empty], error) {
	return c.editChat.CallUnary(ctx, req)
}

// EmojiReply calls api.v1.UserService.EmojiReply.
func (c *userServiceClient) EmojiReply(ctx context.Context, req *connect.Request[v1.EmojiReplyRequest]) (*connect.Response[emptypb.Empty], error) {
	return c.emojiReply.CallUnary(ctx, req)
}

// UserServiceHandler is an implementation of the api.v1.UserService service.
type UserServiceHandler interface {
	ActiveUsers(context.Context, *connect.Request[emptypb.Empty]) (*connect.Response[v1.ActiveUsersResponse], error)
	UpdateDetails(context.Context, *connect.Request[v1.UpdateDetailsRequest]) (*connect.Response[emptypb.Empty], error)
	UpdateStatus(context.Context, *connect.Request[v1.UpdateStatusRequest]) (*connect.Response[emptypb.Empty], error)
	IndicateTyping(context.Context, *connect.Request[v1.IndicateTypingRequest]) (*connect.Response[emptypb.Empty], error)
	SendChat(context.Context, *connect.Request[v1.SendChatRequest]) (*connect.Response[emptypb.Empty], error)
	EditChat(context.Context, *connect.Request[v1.ChatEditEvent]) (*connect.Response[emptypb.Empty], error)
	EmojiReply(context.Context, *connect.Request[v1.EmojiReplyRequest]) (*connect.Response[emptypb.Empty], error)
}

// NewUserServiceHandler builds an HTTP handler from the service implementation. It returns the path
// on which to mount the handler and the handler itself.
//
// By default, handlers support the Connect, gRPC, and gRPC-Web protocols with the binary Protobuf
// and JSON codecs. They also support gzip compression.
func NewUserServiceHandler(svc UserServiceHandler, opts ...connect.HandlerOption) (string, http.Handler) {
	userServiceMethods := v1.File_api_v1_apiv1_proto.Services().ByName("UserService").Methods()
	userServiceActiveUsersHandler := connect.NewUnaryHandler(
		UserServiceActiveUsersProcedure,
		svc.ActiveUsers,
		connect.WithSchema(userServiceMethods.ByName("ActiveUsers")),
		connect.WithHandlerOptions(opts...),
	)
	userServiceUpdateDetailsHandler := connect.NewUnaryHandler(
		UserServiceUpdateDetailsProcedure,
		svc.UpdateDetails,
		connect.WithSchema(userServiceMethods.ByName("UpdateDetails")),
		connect.WithHandlerOptions(opts...),
	)
	userServiceUpdateStatusHandler := connect.NewUnaryHandler(
		UserServiceUpdateStatusProcedure,
		svc.UpdateStatus,
		connect.WithSchema(userServiceMethods.ByName("UpdateStatus")),
		connect.WithHandlerOptions(opts...),
	)
	userServiceIndicateTypingHandler := connect.NewUnaryHandler(
		UserServiceIndicateTypingProcedure,
		svc.IndicateTyping,
		connect.WithSchema(userServiceMethods.ByName("IndicateTyping")),
		connect.WithHandlerOptions(opts...),
	)
	userServiceSendChatHandler := connect.NewUnaryHandler(
		UserServiceSendChatProcedure,
		svc.SendChat,
		connect.WithSchema(userServiceMethods.ByName("SendChat")),
		connect.WithHandlerOptions(opts...),
	)
	userServiceEditChatHandler := connect.NewUnaryHandler(
		UserServiceEditChatProcedure,
		svc.EditChat,
		connect.WithSchema(userServiceMethods.ByName("EditChat")),
		connect.WithHandlerOptions(opts...),
	)
	userServiceEmojiReplyHandler := connect.NewUnaryHandler(
		UserServiceEmojiReplyProcedure,
		svc.EmojiReply,
		connect.WithSchema(userServiceMethods.ByName("EmojiReply")),
		connect.WithHandlerOptions(opts...),
	)
	return "/api.v1.UserService/", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		switch r.URL.Path {
		case UserServiceActiveUsersProcedure:
			userServiceActiveUsersHandler.ServeHTTP(w, r)
		case UserServiceUpdateDetailsProcedure:
			userServiceUpdateDetailsHandler.ServeHTTP(w, r)
		case UserServiceUpdateStatusProcedure:
			userServiceUpdateStatusHandler.ServeHTTP(w, r)
		case UserServiceIndicateTypingProcedure:
			userServiceIndicateTypingHandler.ServeHTTP(w, r)
		case UserServiceSendChatProcedure:
			userServiceSendChatHandler.ServeHTTP(w, r)
		case UserServiceEditChatProcedure:
			userServiceEditChatHandler.ServeHTTP(w, r)
		case UserServiceEmojiReplyProcedure:
			userServiceEmojiReplyHandler.ServeHTTP(w, r)
		default:
			http.NotFound(w, r)
		}
	})
}

// UnimplementedUserServiceHandler returns CodeUnimplemented from all methods.
type UnimplementedUserServiceHandler struct{}

func (UnimplementedUserServiceHandler) ActiveUsers(context.Context, *connect.Request[emptypb.Empty]) (*connect.Response[v1.ActiveUsersResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("api.v1.UserService.ActiveUsers is not implemented"))
}

func (UnimplementedUserServiceHandler) UpdateDetails(context.Context, *connect.Request[v1.UpdateDetailsRequest]) (*connect.Response[emptypb.Empty], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("api.v1.UserService.UpdateDetails is not implemented"))
}

func (UnimplementedUserServiceHandler) UpdateStatus(context.Context, *connect.Request[v1.UpdateStatusRequest]) (*connect.Response[emptypb.Empty], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("api.v1.UserService.UpdateStatus is not implemented"))
}

func (UnimplementedUserServiceHandler) IndicateTyping(context.Context, *connect.Request[v1.IndicateTypingRequest]) (*connect.Response[emptypb.Empty], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("api.v1.UserService.IndicateTyping is not implemented"))
}

func (UnimplementedUserServiceHandler) SendChat(context.Context, *connect.Request[v1.SendChatRequest]) (*connect.Response[emptypb.Empty], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("api.v1.UserService.SendChat is not implemented"))
}

func (UnimplementedUserServiceHandler) EditChat(context.Context, *connect.Request[v1.ChatEditEvent]) (*connect.Response[emptypb.Empty], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("api.v1.UserService.EditChat is not implemented"))
}

func (UnimplementedUserServiceHandler) EmojiReply(context.Context, *connect.Request[v1.EmojiReplyRequest]) (*connect.Response[emptypb.Empty], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("api.v1.UserService.EmojiReply is not implemented"))
}

// EventsServiceClient is a client for the api.v1.EventsService service.
type EventsServiceClient interface {
	PreviousEvents(context.Context, *connect.Request[v1.PreviousEventsRequest]) (*connect.Response[v1.PreviousEventsResponse], error)
	EventStream(context.Context, *connect.Request[emptypb.Empty]) (*connect.ServerStreamForClient[v1.EventStreamResponse], error)
}

// NewEventsServiceClient constructs a client for the api.v1.EventsService service. By default, it
// uses the Connect protocol with the binary Protobuf Codec, asks for gzipped responses, and sends
// uncompressed requests. To use the gRPC or gRPC-Web protocols, supply the connect.WithGRPC() or
// connect.WithGRPCWeb() options.
//
// The URL supplied here should be the base URL for the Connect or gRPC server (for example,
// http://api.acme.com or https://acme.com/grpc).
func NewEventsServiceClient(httpClient connect.HTTPClient, baseURL string, opts ...connect.ClientOption) EventsServiceClient {
	baseURL = strings.TrimRight(baseURL, "/")
	eventsServiceMethods := v1.File_api_v1_apiv1_proto.Services().ByName("EventsService").Methods()
	return &eventsServiceClient{
		previousEvents: connect.NewClient[v1.PreviousEventsRequest, v1.PreviousEventsResponse](
			httpClient,
			baseURL+EventsServicePreviousEventsProcedure,
			connect.WithSchema(eventsServiceMethods.ByName("PreviousEvents")),
			connect.WithClientOptions(opts...),
		),
		eventStream: connect.NewClient[emptypb.Empty, v1.EventStreamResponse](
			httpClient,
			baseURL+EventsServiceEventStreamProcedure,
			connect.WithSchema(eventsServiceMethods.ByName("EventStream")),
			connect.WithClientOptions(opts...),
		),
	}
}

// eventsServiceClient implements EventsServiceClient.
type eventsServiceClient struct {
	previousEvents *connect.Client[v1.PreviousEventsRequest, v1.PreviousEventsResponse]
	eventStream    *connect.Client[emptypb.Empty, v1.EventStreamResponse]
}

// PreviousEvents calls api.v1.EventsService.PreviousEvents.
func (c *eventsServiceClient) PreviousEvents(ctx context.Context, req *connect.Request[v1.PreviousEventsRequest]) (*connect.Response[v1.PreviousEventsResponse], error) {
	return c.previousEvents.CallUnary(ctx, req)
}

// EventStream calls api.v1.EventsService.EventStream.
func (c *eventsServiceClient) EventStream(ctx context.Context, req *connect.Request[emptypb.Empty]) (*connect.ServerStreamForClient[v1.EventStreamResponse], error) {
	return c.eventStream.CallServerStream(ctx, req)
}

// EventsServiceHandler is an implementation of the api.v1.EventsService service.
type EventsServiceHandler interface {
	PreviousEvents(context.Context, *connect.Request[v1.PreviousEventsRequest]) (*connect.Response[v1.PreviousEventsResponse], error)
	EventStream(context.Context, *connect.Request[emptypb.Empty], *connect.ServerStream[v1.EventStreamResponse]) error
}

// NewEventsServiceHandler builds an HTTP handler from the service implementation. It returns the
// path on which to mount the handler and the handler itself.
//
// By default, handlers support the Connect, gRPC, and gRPC-Web protocols with the binary Protobuf
// and JSON codecs. They also support gzip compression.
func NewEventsServiceHandler(svc EventsServiceHandler, opts ...connect.HandlerOption) (string, http.Handler) {
	eventsServiceMethods := v1.File_api_v1_apiv1_proto.Services().ByName("EventsService").Methods()
	eventsServicePreviousEventsHandler := connect.NewUnaryHandler(
		EventsServicePreviousEventsProcedure,
		svc.PreviousEvents,
		connect.WithSchema(eventsServiceMethods.ByName("PreviousEvents")),
		connect.WithHandlerOptions(opts...),
	)
	eventsServiceEventStreamHandler := connect.NewServerStreamHandler(
		EventsServiceEventStreamProcedure,
		svc.EventStream,
		connect.WithSchema(eventsServiceMethods.ByName("EventStream")),
		connect.WithHandlerOptions(opts...),
	)
	return "/api.v1.EventsService/", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		switch r.URL.Path {
		case EventsServicePreviousEventsProcedure:
			eventsServicePreviousEventsHandler.ServeHTTP(w, r)
		case EventsServiceEventStreamProcedure:
			eventsServiceEventStreamHandler.ServeHTTP(w, r)
		default:
			http.NotFound(w, r)
		}
	})
}

// UnimplementedEventsServiceHandler returns CodeUnimplemented from all methods.
type UnimplementedEventsServiceHandler struct{}

func (UnimplementedEventsServiceHandler) PreviousEvents(context.Context, *connect.Request[v1.PreviousEventsRequest]) (*connect.Response[v1.PreviousEventsResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("api.v1.EventsService.PreviousEvents is not implemented"))
}

func (UnimplementedEventsServiceHandler) EventStream(context.Context, *connect.Request[emptypb.Empty], *connect.ServerStream[v1.EventStreamResponse]) error {
	return connect.NewError(connect.CodeUnimplemented, errors.New("api.v1.EventsService.EventStream is not implemented"))
}
